```{r setup, include=FALSE}
# Load necessary libraries
library(signal)

```
1. Read and Preprocess Data

```{r}
# Read text data
lines <- readLines("arm.txt")

# Extract x, y, z from each line
extract_xyz <- function(line) {
  matches <- regmatches(line, gregexpr("-?\\d+\\.\\d+", line))
  as.numeric(unlist(matches))
}

# Apply extraction function
xyz_data <- t(sapply(lines, extract_xyz))
colnames(xyz_data) <- c("x", "y", "z")
df <- as.data.frame(xyz_data)

# Add time column assuming constant sampling rate
dt <- 0.05
df$time <- seq(0, by = dt, length.out = nrow(df))

```
2. Smooth the Signal

```{r}
# Smooth z(t) to reduce noise using simple moving average
z <- df$z
time <- df$time
z_smooth <- stats::filter(z, rep(1/5, 5), sides = 2)
z_smooth <- na.omit(z_smooth)  # Remove NAs generated by filter
time <- time[seq_along(z_smooth)]  # Synchronize time vector
# Take absolute value to include both positive and negative peaks
z_abs <- abs(z_smooth)
```
3. Detect Global Maximum as Excitation Start
```{r}
# Find the index of the global maximum in the absolute signal
max_idx <- which.max(z_abs)

# Cut signal from the global peak onwards
z_cut <- z_smooth[max_idx:length(z_smooth)]
z_abs_cut <- abs(z_cut)
time_cut <- time[max_idx:length(time)]
```



3. Flexible Peak Detection and Filtering Only Decreasing Peaks

```{r}
# New peak detection function: find peaks both in positive and negative directions
find_peaks_bidirectional <- function(signal, min_height = 0.05, min_distance = 3) {
  signal <- na.omit(signal)
  
  # Find local maxima
  pos_peaks <- which(diff(sign(diff(signal))) == -2) + 1
  
  # Find local minima (by reversing signal)
  neg_peaks <- which(diff(sign(diff(-signal))) == -2) + 1
  
  # Combine and sort peaks
  all_peaks <- sort(c(pos_peaks, neg_peaks))
  
  # Filter by minimum absolute height
  all_peaks <- all_peaks[abs(signal[all_peaks]) > min_height]
  
  if (length(all_peaks) == 0) {
    return(integer(0))
  }
  
  # Enforce minimum distance between adjacent peaks
  valid_peaks <- c(all_peaks[1])
  for (i in 2:length(all_peaks)) {
    if (!is.na(all_peaks[i]) && (all_peaks[i] - valid_peaks[length(valid_peaks)]) >= min_distance) {
      valid_peaks <- c(valid_peaks, all_peaks[i])
    }
  }
  
  return(valid_peaks)
}
# Detect peaks on original (not absolute) cut signal
peaks_idx <- find_peaks_bidirectional(z_cut, min_height = 0.05, min_distance = 3)

# Extract peaks
peak_times <- time_cut[peaks_idx]
peak_values <- z_cut[peaks_idx]

# Keep only decreasing sequence based on absolute peak values
# Select top N peaks after the global maximum
N_peaks_to_keep <- 8  # or 8, based on data

if (length(peak_times) > N_peaks_to_keep) {
  peak_times <- peak_times[1:N_peaks_to_keep]
  peak_values <- peak_values[1:N_peaks_to_keep]
}


```
4. Estimate Frequency and Damping Ratio

```{r}
# Estimate natural frequency
periods <- diff(peak_times)
est_freq <- 1 / mean(periods)

# Estimate damping ratio using logarithmic decrement
log_decrements <- log(abs(peak_values[-length(peak_values)]) / abs(peak_values[-1]))
est_damping <- mean(log_decrements) / mean(periods)


```

5. Exponential Envelope Fit
```{r}
# Fit exponential decay to selected peaks
fit_n <- min(5, length(peak_times))
fit_env <- lm(log(peak_values[1:fit_n]) ~ peak_times[1:fit_n])
a <- exp(coef(fit_env)[1])
b <- -coef(fit_env)[2]

```
6. Visualization of Signal and Fitted Envelope
```{r}
# Plot signal with detected peaks and exponential fit
plot(time, z_smooth, type = 'l', col = 'steelblue', lwd = 1.5,
     main = 'Signal z(t) with Peaks and Damping Fit',
     xlab = 'Time (s)', ylab = 'z', cex.lab = 1.2, cex.main = 1.5)
points(peak_times, peak_values, col = 'red', pch = 19, cex = 0.8)
lines(peak_times[1:fit_n], a * exp(-b * peak_times[1:fit_n]), col = "darkgreen", lty = 2, lwd = 2)
legend("topright",
       legend = c("z(t)", "Detected Peaks", "Exponential Fit"),
       col = c("steelblue", "red", "darkgreen"),
       lty = c(1, NA, 2), pch = c(NA, 19, NA), lwd = c(1.5, NA, 2))

```

7. Print Results
```{r}
# Print estimated results
cat("Estimated Frequency:", round(est_freq, 3), "Hz\n")
cat("Estimated Damping Coefficient:", round(est_damping, 4), "\n")

```

